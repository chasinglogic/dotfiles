#!/usr/bin/env -S uv run --script
# vi: ft=python

import json
import sys
from typing import Any, Dict, Iterable


COLORS = {
    "reset": "\u001b[0m",
    "red": "\u001b[31m",
    "yellow": "\u001b[33m",
    "cyan": "\u001b[36m",
}

TIMESTAMP_KEYS: tuple[str, ...] = ("time", "timestamp", "ts")
LEVEL_KEYS: tuple[str, ...] = ("level", "levelname", "level_name")
MESSAGE_KEYS: tuple[str, ...] = ("message", "msg")

_EXCLUDE_KEYS = set(TIMESTAMP_KEYS + LEVEL_KEYS + MESSAGE_KEYS)

_cached_timestamp_key: str | None = None
_cached_level_key: str | None = None
_cached_message_key: str | None = None


def color_for_level(level: Any) -> str:
    name = str(level).upper()
    if name == "INFO":
        return COLORS["cyan"]
    if name in {"WARN", "WARNING"}:
        return COLORS["yellow"]
    if name in {"ERR", "ERROR"}:
        return COLORS["red"]
    return COLORS["reset"]


def _discover_key(candidates: Iterable[str], data: Dict[str, Any]) -> str | None:
    for key in candidates:
        if data.get(key) is not None:
            return key
    return None


def timestamp_key(data: Dict[str, Any]) -> str | None:
    global _cached_timestamp_key
    if _cached_timestamp_key is None:
        _cached_timestamp_key = _discover_key(TIMESTAMP_KEYS, data)
    return _cached_timestamp_key


def level_key(data: Dict[str, Any]) -> str | None:
    global _cached_level_key
    if _cached_level_key is None:
        _cached_level_key = _discover_key(LEVEL_KEYS, data)
    return _cached_level_key


def message_key(data: Dict[str, Any]) -> str | None:
    global _cached_message_key
    if _cached_message_key is None:
        _cached_message_key = _discover_key(MESSAGE_KEYS, data)
    return _cached_message_key


def _print_fields(obj: Any, nesting_level: int = 1) -> None:
    if not isinstance(obj, dict):
        return

    prefix = "\t" * nesting_level
    for key, value in obj.items():
        if key in _EXCLUDE_KEYS:
            continue

        if isinstance(value, dict):
            print(f"{prefix}{key} = {{")
            _print_fields(value, nesting_level + 1)
            print(f"{prefix}}}")
        elif isinstance(value, list):
            # Represent lists as an indexed map, similar to the original Clojure code
            print(f"{prefix}{key} = {{")
            indexed = {i: v for i, v in enumerate(value)}
            _print_fields(indexed, nesting_level + 1)
            print(f"{prefix}}}")
        else:
            print(f"{prefix}{key} = {value}")


def _pretty_print(line: str) -> None:
    data = json.loads(line)

    lvl_key = level_key(data)
    ts_key = timestamp_key(data)
    msg_key = message_key(data)

    level = data.get(lvl_key, "INFO") if lvl_key else "INFO"
    timestamp = data.get(ts_key, "") if ts_key else ""
    message = data.get(msg_key, "") if msg_key else ""

    color = color_for_level(level)
    reset = COLORS["reset"]

    print(f"{color}{str(level).upper()}{reset} {timestamp} {message}")
    _print_fields(data, nesting_level=1)


def main() -> int:
    for raw_line in sys.stdin:
        line = raw_line.rstrip("\n")
        if not line:
            continue
        try:
            _pretty_print(line)
        except Exception:
            # Match the behaviour of the original script on non-JSON input
            print(f"NON-JSON LINE: {line}")
    return 0


if __name__ == "__main__":  # pragma: no cover
    raise SystemExit(main())
